#[macro_use]
extern crate error_chain;
#[macro_use]
extern crate serde_json;
extern crate serde;
#[macro_use]
extern crate log;

error_chain! {
    errors {
        /// Error in the underlying transport layer.
        TransportError {
            description("Unable to send the JSONRPC-2.0 request")
        }
        /// Error while serializing method parameters.
        SerializeError {
            description("Unable to serialize the method parameters")
        }
        /// Error while deserializing or parsing the response data.
        DeserializeError(msg: String) {
            description("Unable to deserialize the response into the desired type")
            display("Unable to deserialize the response: {}", msg)
        }
    }
}

/// Trait for types acting as a transport layer for the JSONRPC-2.0 clients generated by the
/// `jsonrpc_client` macro.
pub trait Transport<E: ::std::error::Error + Send + 'static> {
    fn send(&mut self, json_data: &[u8]) -> ::std::result::Result<Vec<u8>, E>;
}


/// The main macro of this crate. Generates JSONRPC-2.0 client structs with automatic serialization
/// and deserialization. Method calls get correct types automatically.
#[macro_export]
macro_rules! jsonrpc_client {
    (
        $(#[$struct_doc:meta])*
        pub struct $struct_name:ident {$(
            $(#[$doc:meta])*
            pub fn $method:ident(&mut $selff:ident $(, $arg_name:ident: $arg_ty:ty)*)
                -> Result<$return_ty:ty>;
        )*}
    ) => (
        $(#[$struct_doc])*
        pub struct $struct_name<E, T>
            where E: ::std::error::Error + Send + 'static, T: $crate::Transport<E>
        {
            transport: T,
            _error: ::std::marker::PhantomData<E>,
        }

        impl<E: ::std::error::Error + Send + 'static, T: $crate::Transport<E>> $struct_name<E, T> {
            /// Creates a new RPC client backed by the given transport implementation.
            pub fn new(transport: T) -> Self {
                $struct_name {
                    transport,
                    _error: ::std::marker::PhantomData,
                }
            }

            $(
                $(#[$doc])*
                pub fn $method(&mut $selff $(, $arg_name: $arg_ty)*) -> $crate::Result<$return_ty> {
                    let params = ($($arg_name,)*);
                    $crate::call_method(&mut $selff.transport, stringify!($method), params)
                }
            )*
        }
    )
}


/// Call a method with a given transport, method and parameters. Not intended for direct use.
/// Is being called from the client structs generated by the `jsonrpc_client` macro.
pub fn call_method<E, T, P, R>(transport: &mut T, method: &str, params: P) -> Result<R>
where
    E: ::std::error::Error + Send + 'static,
    T: Transport<E>,
    P: serde::Serialize,
    for<'de> R: serde::Deserialize<'de>,
{
    let request_json = format_request(method, params);
    let request_raw = serde_json::to_vec(&request_json)
        .chain_err(|| ErrorKind::SerializeError)?;

    debug!("Sending JSONRPC-2.0 request: {}", request_json);
    let response_raw = transport
        .send(&request_raw)
        .chain_err(|| ErrorKind::TransportError)?;

    parse_response::<R>(&response_raw)
}


/// Creates a JSONRPC-2.0 request to the given method with the given parameters.
fn format_request<P>(method: &str, params: P) -> serde_json::Value
where
    P: serde::Serialize,
{
    json!({
        "jsonrpc": "2.0",
        "id": 1,
        "method": method,
        "params": params,
    })
}


/// Parses a binary response into json, extracts the "result" field and tries to deserialize that
/// to the desired type
fn parse_response<T>(response: &[u8]) -> Result<T>
where
    for<'de> T: serde::Deserialize<'de>,
{
    let result_json = get_result_field(response)?;
    debug!("Received json result: {}", result_json);
    serde_json::from_value::<T>(result_json).chain_err(|| {
        ErrorKind::DeserializeError(format!("Result cannot deserialize to {}", stringify!(T)))
    })
}

/// Deserialize the response as json and fetch the "result" field from it.
fn get_result_field(response: &[u8]) -> Result<serde_json::Value> {
    let response_json = serde_json::from_slice(response)
        .chain_err(|| {
            ErrorKind::DeserializeError("Response is not valid json".to_string())
        })?;
    let result_json = match response_json {
        serde_json::Value::Object(mut map) => map.remove("result"),
        _ => None,
    };
    result_json.ok_or(
        ErrorKind::DeserializeError("Response has no \"result\" field".to_string()).into(),
    )
}



jsonrpc_client!(
    /// Just an example RPC client to showcase how to use the `jsonrpc_client` macro and what
    /// the resulting structs look like.
    pub struct ExampleRpcClient {
        pub fn nullary(&mut self) -> Result<()>;

        pub fn echo(&mut self, input: String) -> Result<String>;

        /// Example RPC method named "concat" that takes a `String` and an unsigned integer and
        /// returns a `String`. From the name one could guess it will concatenate the two
        /// arguments. But that of course depends on the server where this call is sent.
        pub fn concat(&mut self, arg0: String, arg1: u64) -> Result<String>;
    }
);



#[cfg(test)]
mod tests {
    use super::*;
    use std::io;

    /// A test transport that just echoes back a response containing the request as the result.
    struct EchoTransport;

    impl Transport<io::Error> for EchoTransport {
        fn send(&mut self, json_data: &[u8]) -> ::std::result::Result<Vec<u8>, io::Error> {
            let json = json!({
                "jsonrpc": "2.0",
                "id": 123,
                "result": serde_json::from_slice::<serde_json::Value>(json_data).unwrap(),
            });
            Ok(serde_json::to_vec(&json).unwrap())
        }
    }

    jsonrpc_client!(pub struct TestRpcClient {
        pub fn ping(&mut self, arg0: String) -> Result<serde_json::Value>;
    });

    #[test]
    fn echo() {
        let mut client = TestRpcClient::new(EchoTransport);
        let result = client.ping("Hello".to_string()).unwrap();
        if let serde_json::Value::Object(mut map) = result {
            assert_eq!(Some(serde_json::Value::String("2.0".to_string())), map.remove("jsonrpc"));
            assert_eq!(Some(serde_json::Value::Number(1.into())), map.remove("id"));
            assert_eq!(Some(serde_json::Value::String("ping".to_string())), map.remove("method"));
            assert_eq!(Some(serde_json::Value::Array(vec!["Hello".into()])), map.remove("params"));
        } else {
            panic!("Invalid response type: {:?}", result);
        }
    }
}
